package ru.yandex.javacourse.schedule.manager;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Test;
import ru.yandex.javacourse.schedule.tasks.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public abstract class TaskManagersTest<T extends TaskManager> {
    private static final Path TASKS_FILE = Paths.get("tasks.csv");

    protected T manager;

    @AfterAll
    public static void cleanUpAll() throws IOException {
        Files.deleteIfExists(TASKS_FILE);
    }

    @Test
    public void testAddTask() {
        Task task = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK);
        manager.addNewTask(task);
        assertEquals(1, manager.getTasks().size(), "task should be added");
        Task addedTask = manager.getTasks().getFirst();
        assertEquals(task, addedTask, "added task id should be set");
        Task byIdTask = manager.getTask(task.getId());
        assertEquals(task, byIdTask, "added task id should be found");
    }

    @Test
    public void testAddTaskWithInterceptingDuration() {
        Task task = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(3), LocalDateTime.now());
        Task task2 = new Task("Test 2", "Testing task 2", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(4), LocalDateTime.now().minusDays(2));
        Task task3 = new Task("Test 3", "Testing task 3", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(10), LocalDateTime.now().minusDays(2));
        Task task4 = new Task("Test 4", "Testing task 4", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(1), LocalDateTime.now().plusDays(1));

        manager.addNewTask(task);
        manager.addNewTask(task2);
        manager.addNewTask(task3);
        manager.addNewTask(task4);

        assertEquals(1, manager.getTasks().size(), "only one task should be added");
        Task addedTask = manager.getTasks().getFirst();
        assertEquals(task, addedTask, "added task id should be set");
        Task byIdTask = manager.getTask(task.getId());
        assertEquals(task, byIdTask, "added task id should be found");
    }

    @Test
    public void testAddTaskWithId(){
        Task task = new Task(42, "Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK, Duration.ofMinutes(20), LocalDateTime.now());
        manager.addNewTask(task);
        assertEquals(1, manager.getTasks().size(), "task should be added");
        Task addedTask = manager.getTasks().getFirst();
        assertEquals(task, addedTask, "predefined task id should be set");
    }

    @Test
    public void testAddTaskWithAndWithoutId(){
        Task task0 = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK, Duration.ofMinutes(20), LocalDateTime.now());
        Task task1 = new Task(1, "Test 2", "Testing task 2", TaskStatus.NEW, TaskType.TASK, Duration.ofMinutes(20), LocalDateTime.now().minusDays(3));
        manager.addNewTask(task0);
        manager.addNewTask(task1);

        assertEquals(2, manager.getTasks().size(), "lost a task with predefined id");
        assertEquals(1, task0.getId(), "autogenerated id should be 1");
        assertEquals(2, task1.getId(), "task id has to be sequential");
    }

    @Test
    public void checkTaskNotChangedAfterAddTask() {
        int id = 1;
        String name = "Test 1";
        String description = "Testing task 1";
        TaskStatus status = TaskStatus.NEW;
        TaskType taskType = TaskType.TASK;
        Task task1before = new Task(id, name, description, status, taskType, Duration.ofMinutes(20), LocalDateTime.now());
        manager.addNewTask(task1before);
        Task task1after = manager.getTask(task1before.getId());
        assertEquals(id, task1after.getId());
        assertEquals(description, task1after.getDescription());
        assertEquals(status, task1after.getStatus());
        assertEquals(name, task1after.getName());
    }

    @Test
    public void checkTaskRemoval() {
        Task task0 = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK, Duration.ofMinutes(20), LocalDateTime.now());
        Task task1 = new Task(1, "Test 2", "Testing task 2", TaskStatus.NEW, TaskType.TASK, Duration.ofMinutes(20), LocalDateTime.now().minusDays(3));
        manager.addNewTask(task0);
        manager.addNewTask(task1);
        manager.getTask(task0.getId());
        manager.getTask(task1.getId());

        manager.deleteTask(task0.getId());

        List<Integer> historyTaskIds = manager.getHistory().stream().map(Task::getId).toList();
        List<Task> remainingTasks = manager.getTasks();
        List<Task> prioritizedTasks = manager.getPrioritizedTasks();
        assertEquals(1, remainingTasks.size(), "remaining task should also be removed");
        assertEquals(1, historyTaskIds.size(), "task should also be removed from history");
        assertEquals(1, prioritizedTasks.size(), "task should also be removed from prioritized tasks");
        assertEquals(List.of(task1.getId()), historyTaskIds);
        assertEquals(List.of(task1.getId()), List.of(prioritizedTasks.getFirst().getId()));
    }

    @Test
    public void checkEpicSubtaskRemoval() {
        Epic epic = new Epic("Epic1", "Epic desc");
        int epicId = manager.addNewEpic(epic);
        List<Subtask> epicSubtasks = getEpicSubtasks(epicId);
        List<Integer> subTaskIds = epicSubtasks.stream().map(manager::addNewSubtask).toList();
        manager.getEpic(epicId);
        manager.getSubtask(subTaskIds.get(0));
        manager.getSubtask(subTaskIds.get(1));

        manager.deleteSubtask(subTaskIds.get(0));

        List<Task> history = manager.getHistory();
        List<Task> prioritizedTasks = manager.getPrioritizedTasks();
        assertEquals(3, prioritizedTasks.size(), "Must also remove subtask from prioritized tasks");
        assertFalse(history.contains(epicSubtasks.getFirst()));
        assertTrue(history.contains(epic));
        assertEquals("SubT4", prioritizedTasks.getFirst().getName());
    }

    @Test
    public void checkEpicRemoval() {
        Epic epic = new Epic("Epic1", "Epic desc");
        int epicId = manager.addNewEpic(epic);
        List<Subtask> epicSubtasks = getEpicSubtasks(epicId);
        List<Integer> subTaskIds = epicSubtasks.stream().map(manager::addNewSubtask).toList();
        manager.getEpic(epicId);
        manager.getSubtask(subTaskIds.get(0));
        manager.getSubtask(subTaskIds.get(1));

        manager.deleteEpic(epicId);

        assertTrue(manager.getHistory().isEmpty());
        assertTrue(manager.getSubtasks().isEmpty());
        assertTrue(manager.getEpics().isEmpty());
    }

    @Test
    public void checkTaskPriority() {
        Task task = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(3), LocalDateTime.now());
        Task task2 = new Task("Test 2", "Testing task 2", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(4), LocalDateTime.now().minusDays(2));
        Task task3 = new Task("Test 3", "Testing task 3", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(10), LocalDateTime.now().minusDays(3));
        Task task4 = new Task("Test 4", "Testing task 4", TaskStatus.NEW, TaskType.TASK, Duration.ofDays(1), LocalDateTime.now().plusDays(1));
        manager.addNewTask(task);
        manager.addNewTask(task2);
        manager.addNewTask(task3);
        manager.addNewTask(task4);

        List<Task> prioritizedTasks = manager.getPrioritizedTasks();

        ArrayList<Task> sortedByStartDate = new ArrayList<>(prioritizedTasks);
        sortedByStartDate.sort(Comparator.comparing(Task::getStartTime));
        assertEquals(sortedByStartDate, prioritizedTasks);
    }

    @Test
    public void testTaskWithoutStartDate() {
        Task task = new Task("Test 1", "Testing task 1", TaskStatus.NEW, TaskType.TASK);
        manager.addNewTask(task);

        List<Task> prioritizedTasks = manager.getPrioritizedTasks();

        assertTrue(prioritizedTasks.isEmpty());
    }

    private List<Subtask> getEpicSubtasks(int epicId) {
        return List.of(
                new Subtask("SubT1", "Desc1", TaskStatus.NEW, epicId, Duration.ofMinutes(30), LocalDateTime.now().minusDays(1)),
                new Subtask("SubT2", "Desc2", TaskStatus.NEW, epicId, Duration.ofMinutes(30), LocalDateTime.now().minusDays(2)),
                new Subtask("SubT3", "Desc3", TaskStatus.NEW, epicId, Duration.ofMinutes(30), LocalDateTime.now().minusDays(3)),
                new Subtask("SubT4", "Desc4", TaskStatus.NEW, epicId, Duration.ofMinutes(30), LocalDateTime.now().minusDays(4))
        );
    }
}
